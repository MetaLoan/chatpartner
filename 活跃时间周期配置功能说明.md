# 活跃时间周期配置功能说明

## 功能概述

活跃时间周期配置功能允许为AI账号设置独立的活跃时间段，或设置全局默认的活跃时间段。在非活跃时间段内，AI账号将不会主动发言（除非被@提及，可配置）。

## 功能特性

### 1. 配置级别

#### 1.1 账号独立配置
- 每个AI账号可以设置自己独特的活跃时间周期
- 账号独立配置优先级高于全局配置
- 支持为不同账号设置不同的时区

#### 1.2 全局配置
- 设置所有账号的默认活跃时间周期
- 未设置独立配置的账号将使用全局配置
- 支持一键应用全局配置到所有账号

### 2. 时间周期配置方式

#### 2.1 按星期配置（Weekly）
- 选择一周中的特定日期（周一至周日）
- 可以设置每天不同的时间段
- 示例：
  - 工作日（周一至周五）：09:00-18:00
  - 周末（周六、周日）：10:00-20:00

#### 2.2 按日期范围配置（Date Range）
- 设置开始日期和结束日期
- 适用于特定活动期间的配置
- 示例：
  - 2024-01-01 至 2024-01-31：全天活跃
  - 2024-02-01 至 2024-02-07：09:00-17:00

#### 2.3 按时间段配置（Time Slot）
- 设置每日的活跃时间段
- 支持多个时间段组合
- 示例：
  - 时间段1：09:00-12:00
  - 时间段2：14:00-18:00

### 3. 时区支持

- 每个账号可以设置独立的时区
- 全局配置也可以设置时区
- 支持所有标准时区（UTC、Asia/Shanghai、America/New_York等）
- 自动处理夏令时转换

### 4. 优先级机制

- **账号独立配置** > **全局配置**
- 如果账号设置了独立配置，则使用账号配置
- 如果账号未设置独立配置，则使用全局配置
- 如果账号和全局都未设置，则默认全天活跃

### 5. 行为控制

#### 5.1 活跃时间段内
- AI账号可以正常主动发言
- 响应@提及
- 响应关键词触发
- 执行定时任务

#### 5.2 非活跃时间段内
- AI账号不主动发言
- 可以配置是否响应@提及（默认：响应）
- 可以配置是否响应关键词（默认：不响应）
- 定时任务可以配置是否执行（默认：不执行）

## 使用场景

### 场景1：工作时间配置
- 配置账号在工作日09:00-18:00活跃
- 周末和晚上不发言，避免打扰

### 场景2：时区差异
- 不同地区的账号设置不同时区
- 确保在对应地区的活跃时间段发言

### 场景3：活动期间
- 特定活动期间设置全天活跃
- 活动结束后恢复常规配置

### 场景4：批量管理
- 设置全局配置，所有账号默认使用
- 特殊账号单独配置

## 前端界面设计

### 1. 账号管理页面
- 在账号编辑界面添加"活跃时间周期"标签页
- 可视化时间选择器
- 支持复制其他账号配置
- 支持应用全局配置

### 2. 系统设置页面
- 全局活跃时间周期配置区域
- 配置预览和测试功能
- 批量应用功能

### 3. 时间周期配置界面
- **日历选择器**：选择日期范围
- **星期选择器**：选择星期几
- **时间段选择器**：选择开始和结束时间
- **时区选择器**：选择时区
- **配置预览**：实时预览配置效果
- **测试功能**：测试当前时间是否在活跃时间段内

## 后端实现要点

### 1. 数据模型
```python
class AccountActivePeriod(Base):
    account_id: int
    period_type: str  # weekly/date_range/time_slot
    day_of_week: List[int]  # 0-6
    date_start: Optional[date]
    date_end: Optional[date]
    time_start: Optional[time]
    time_end: Optional[time]
    timezone: str
    enabled: bool
    priority: int
```

### 2. 核心逻辑

#### 2.1 判断是否在活跃时间段
```python
def is_in_active_period(account_id: int, current_time: datetime) -> bool:
    # 1. 获取账号独立配置
    account_periods = get_account_periods(account_id)
    if account_periods:
        return check_periods(account_periods, current_time)
    
    # 2. 获取全局配置
    global_periods = get_global_periods()
    if global_periods:
        return check_periods(global_periods, current_time)
    
    # 3. 默认全天活跃
    return True
```

#### 2.2 时间周期检查
```python
def check_periods(periods: List[Period], current_time: datetime) -> bool:
    for period in periods:
        if not period.enabled:
            continue
        
        # 转换时区
        local_time = current_time.astimezone(period.timezone)
        
        # 检查星期
        if period.period_type == 'weekly':
            if local_time.weekday() not in period.day_of_week:
                continue
        
        # 检查日期范围
        if period.period_type == 'date_range':
            if not (period.date_start <= local_time.date() <= period.date_end):
                continue
        
        # 检查时间段
        if period.time_start and period.time_end:
            current_time_only = local_time.time()
            if not (period.time_start <= current_time_only <= period.time_end):
                continue
        
        return True
    
    return False
```

### 3. API接口

#### 3.1 账号活跃时间周期
- `GET /api/accounts/{id}/active-period` - 获取配置
- `PUT /api/accounts/{id}/active-period` - 更新配置
- `DELETE /api/accounts/{id}/active-period` - 删除配置（使用全局）

#### 3.2 全局活跃时间周期
- `GET /api/configs/global-active-period` - 获取全局配置
- `PUT /api/configs/global-active-period` - 更新全局配置

#### 3.3 批量操作
- `POST /api/accounts/{id}/active-period/apply-global` - 应用全局配置
- `POST /api/accounts/batch-active-period` - 批量设置

#### 3.4 状态查询
- `GET /api/accounts/{id}/active-status` - 查询当前是否在活跃时间段

## 发言控制集成

### 1. 消息处理流程
```python
async def handle_message(event, account_id):
    # 1. 检查是否在活跃时间段
    if not is_in_active_period(account_id, datetime.now()):
        # 2. 检查是否是被@提及
        if event.message.mentioned:
            # 3. 检查是否允许非活跃时间段响应@提及
            if should_reply_when_inactive(account_id):
                await generate_and_send_reply(event)
        return
    
    # 4. 正常处理消息
    await process_message(event)
```

### 2. 定时任务集成
```python
async def execute_scheduled_task(task):
    # 检查是否在活跃时间段
    if not is_in_active_period(task.account_id, datetime.now()):
        # 检查任务是否允许在非活跃时间段执行
        if not task.allow_inactive_period:
            logger.info(f"任务 {task.id} 跳过：不在活跃时间段")
            return
    
    await send_message(task)
```

## 配置示例

### 示例1：工作日配置
```json
{
  "period_type": "weekly",
  "day_of_week": [0, 1, 2, 3, 4],  // 周一到周五
  "time_start": "09:00:00",
  "time_end": "18:00:00",
  "timezone": "Asia/Shanghai"
}
```

### 示例2：多时间段配置
```json
[
  {
    "period_type": "weekly",
    "day_of_week": [0, 1, 2, 3, 4],
    "time_start": "09:00:00",
    "time_end": "12:00:00",
    "timezone": "Asia/Shanghai",
    "priority": 1
  },
  {
    "period_type": "weekly",
    "day_of_week": [0, 1, 2, 3, 4],
    "time_start": "14:00:00",
    "time_end": "18:00:00",
    "timezone": "Asia/Shanghai",
    "priority": 2
  }
]
```

### 示例3：活动期间配置
```json
{
  "period_type": "date_range",
  "date_start": "2024-01-01",
  "date_end": "2024-01-31",
  "time_start": "00:00:00",
  "time_end": "23:59:59",
  "timezone": "Asia/Shanghai"
}
```

## 注意事项

### 1. 时区处理
- 所有时间存储使用UTC
- 显示时转换为用户设置的时区
- 计算时考虑夏令时

### 2. 性能优化
- 缓存活跃时间段配置
- 定期刷新缓存（如每小时）
- 使用Redis存储当前活跃状态

### 3. 边界情况
- 跨天的时间段处理（如22:00-02:00）
- 时区切换时的处理
- 配置更新时的平滑过渡

### 4. 用户体验
- 提供配置预览功能
- 显示当前是否在活跃时间段
- 提供配置模板和示例

## 测试要点

### 1. 功能测试
- 不同时间周期类型的配置
- 时区转换正确性
- 优先级机制
- 边界时间点处理

### 2. 性能测试
- 大量账号的配置查询性能
- 缓存机制有效性
- 并发访问处理

### 3. 集成测试
- 与发言控制模块的集成
- 与定时任务模块的集成
- 与自动回复模块的集成

